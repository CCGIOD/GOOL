* Dans builtin_type_specifier() : | t="bool" {jjtThis.value = "boolean";}

* Modification de ADDITIVE_EXPRESSION et MULTIPLICATION_EXPRESSION par :
void additive_expression() #ADDITIVE_EXPRESSION :
{java.util.List<String> l = new java.util.ArrayList<String>();}
{    multiplicative_expression()
   (LOOKAHEAD(2) ( "+" {l.add("+"); } | "-" {l.add("-"); }) multiplicative_expression())* {jjtThis.value = l; }
}

void multiplicative_expression() #MULTIPLICATIVE_EXPRESSION :
{java.util.List<String> l = new java.util.ArrayList<String>();}
{  pm_expression()
   (LOOKAHEAD(2) ( "*" {l.add("*"); } | "/" {l.add("/"); } | "%" {l.add("%"); }) pm_expression())* {jjtThis.value = l; }
}

* Dans translation_unit() :    { sym.OpenScope(null, false); sym.PutTypeName("Test"); } // A am√©liorer

* Modification de type_qualifier par : 
void type_qualifier() #TYPE_QUALIFIER :
{}
{
    "const" {jjtThis.value = "const";} | "volatile" {jjtThis.value = "volatile";}
}

* Modification de storage_class_specifier par :
boolean storage_class_specifier() #STORAGE_CLASS_SPECIFIER :
{}
{
   ( "auto" | "register" | "static" {jjtThis.value = "static";} | "extern" ) { return false; }
   | "typedef"  { return true; }
}

* Modification de handler par :
void handler() #HANDLER :
{}
{
   "catch" "(" exception_declaration() ")" {jjtThis.value="catch";}
   compound_statement()
 |
   "finally" compound_statement() {jjtThis.value="finally";}
}

* Modification dans ptr_operator par :
void ptr_operator() #PTR_OPERATOR :
{}
{
    "&" cv_qualifier_seq()
   |
    "*" cv_qualifier_seq() {jjtThis.value="*";}
   |
    ptr_to_member() cv_qualifier_seq()
}

