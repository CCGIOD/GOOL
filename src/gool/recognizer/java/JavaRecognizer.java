/**
 * This is a Visitor. It visits the Java abstract syntax tree generated by Sun's java parser, to produce a GOOL abstract syntax tree.
 * 
 */


package gool.recognizer.java;

import gool.ast.bufferedreader.BufferedReaderCloseCall;
import gool.ast.bufferedreader.BufferedReaderReadCall;
import gool.ast.bufferedreader.BufferedReaderReadLineCall;
import gool.ast.bufferedwriter.BufferedWriterCloseCall;
import gool.ast.bufferedwriter.BufferedWriterFlushCall;
import gool.ast.bufferedwriter.BufferedWriterNewLineCall;
import gool.ast.bufferedwriter.BufferedWriterWriteCall;
import gool.ast.constructs.ArrayAccess;
import gool.ast.constructs.ArrayNew;
import gool.ast.constructs.Assign;
import gool.ast.constructs.BinaryOperation;
import gool.ast.constructs.Block;
import gool.ast.constructs.CastExpression;
import gool.ast.constructs.Catch;
import gool.ast.constructs.ClassDef;
import gool.ast.constructs.ClassNew;
import gool.ast.constructs.Comment;
import gool.ast.constructs.Constant;
import gool.ast.constructs.Constructor;
import gool.ast.constructs.CustomDependency;
import gool.ast.constructs.Dec;
import gool.ast.constructs.Dependency;
import gool.ast.constructs.EnhancedForLoop;
import gool.ast.constructs.EqualsCall;
import gool.ast.constructs.Expression;
import gool.ast.constructs.ExpressionUnknown;
import gool.ast.constructs.Field;
import gool.ast.constructs.For;
import gool.ast.constructs.If;
import gool.ast.constructs.InitCall;
import gool.ast.constructs.MainMeth;
import gool.ast.constructs.MemberSelect;
import gool.ast.constructs.Meth;
import gool.ast.constructs.MethCall;
import gool.ast.constructs.Modifier;
import gool.ast.constructs.Node;
import gool.ast.constructs.Operator;
import gool.ast.constructs.Package;
import gool.ast.constructs.Parameterizable;
import gool.ast.constructs.ParentCall;
import gool.ast.constructs.Return;
import gool.ast.constructs.Statement;
import gool.ast.constructs.ThisCall;
import gool.ast.constructs.ToStringCall;
import gool.ast.constructs.Try;
import gool.ast.constructs.TypeDependency;
import gool.ast.constructs.UnaryOperation;
import gool.ast.constructs.VarAccess;
import gool.ast.constructs.VarDeclaration;
import gool.ast.constructs.While;
import gool.ast.exception.ExceptionPrintStackTraceCall;
import gool.ast.file.FileDeleteCall;
import gool.ast.file.FileExistsCall;
import gool.ast.file.FileIsDirectoryCall;
import gool.ast.file.FileIsFileCall;
import gool.ast.list.ListAddCall;
import gool.ast.list.ListContainsCall;
import gool.ast.list.ListGetCall;
import gool.ast.list.ListGetIteratorCall;
import gool.ast.list.ListIsEmptyCall;
import gool.ast.list.ListRemoveAtCall;
import gool.ast.list.ListRemoveCall;
import gool.ast.list.ListSizeCall;
import gool.ast.map.MapContainsKeyCall;
import gool.ast.map.MapEntryGetKeyCall;
import gool.ast.map.MapEntryGetValueCall;
import gool.ast.map.MapGetCall;
import gool.ast.map.MapGetIteratorCall;
import gool.ast.map.MapIsEmptyCall;
import gool.ast.map.MapPutCall;
import gool.ast.map.MapRemoveCall;
import gool.ast.map.MapSizeCall;
import gool.ast.system.SystemOutDependency;
import gool.ast.system.SystemOutPrintCall;
import gool.ast.type.IType;
import gool.ast.type.TypeArray;
import gool.ast.type.TypeBool;
import gool.ast.type.TypeBufferedReader;
import gool.ast.type.TypeBufferedWriter;
import gool.ast.type.TypeByte;
import gool.ast.type.TypeChar;
import gool.ast.type.TypeClass;
import gool.ast.type.TypeDecimal;
import gool.ast.type.TypeEntry;
import gool.ast.type.TypeException;
import gool.ast.type.TypeFile;
import gool.ast.type.TypeFileReader;
import gool.ast.type.TypeFileWriter;
import gool.ast.type.TypeInt;
import gool.ast.type.TypeList;
import gool.ast.type.TypeMap;
import gool.ast.type.TypeMethod;
import gool.ast.type.TypeNone;
import gool.ast.type.TypeNull;
import gool.ast.type.TypeObject;
import gool.ast.type.TypePackage;
import gool.ast.type.TypeString;
import gool.ast.type.TypeUnknown;
import gool.ast.type.TypeVar;
import gool.ast.type.TypeVoid;
import gool.generator.common.Platform;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.lang.model.type.ArrayType;
import javax.lang.model.type.TypeKind;
import javax.lang.model.type.TypeMirror;

import org.apache.log4j.Logger;

import com.sun.source.tree.AnnotationTree;
import com.sun.source.tree.ArrayAccessTree;
import com.sun.source.tree.ArrayTypeTree;
import com.sun.source.tree.AssertTree;
import com.sun.source.tree.AssignmentTree;
import com.sun.source.tree.BinaryTree;
import com.sun.source.tree.BlockTree;
import com.sun.source.tree.BreakTree;
import com.sun.source.tree.CaseTree;
import com.sun.source.tree.CatchTree;
import com.sun.source.tree.ClassTree;
import com.sun.source.tree.CompilationUnitTree;
import com.sun.source.tree.CompoundAssignmentTree;
import com.sun.source.tree.ConditionalExpressionTree;
import com.sun.source.tree.ContinueTree;
import com.sun.source.tree.DoWhileLoopTree;
import com.sun.source.tree.EmptyStatementTree;
import com.sun.source.tree.EnhancedForLoopTree;
import com.sun.source.tree.ErroneousTree;
import com.sun.source.tree.ExpressionStatementTree;
import com.sun.source.tree.ExpressionTree;
import com.sun.source.tree.ForLoopTree;
import com.sun.source.tree.IdentifierTree;
import com.sun.source.tree.IfTree;
import com.sun.source.tree.ImportTree;
import com.sun.source.tree.InstanceOfTree;
import com.sun.source.tree.LabeledStatementTree;
import com.sun.source.tree.LiteralTree;
import com.sun.source.tree.MemberSelectTree;
import com.sun.source.tree.MethodInvocationTree;
import com.sun.source.tree.MethodTree;
import com.sun.source.tree.ModifiersTree;
import com.sun.source.tree.NewArrayTree;
import com.sun.source.tree.NewClassTree;
import com.sun.source.tree.ParameterizedTypeTree;
import com.sun.source.tree.ParenthesizedTree;
import com.sun.source.tree.PrimitiveTypeTree;
import com.sun.source.tree.ReturnTree;
import com.sun.source.tree.StatementTree;
import com.sun.source.tree.SwitchTree;
import com.sun.source.tree.SynchronizedTree;
import com.sun.source.tree.ThrowTree;
import com.sun.source.tree.Tree;
import com.sun.source.tree.Tree.Kind;
import com.sun.source.tree.TryTree;
import com.sun.source.tree.TypeCastTree;
import com.sun.source.tree.TypeParameterTree;
import com.sun.source.tree.UnaryTree;
import com.sun.source.tree.VariableTree;
import com.sun.source.tree.WhileLoopTree;
import com.sun.source.tree.WildcardTree;
import com.sun.source.util.TreePath;
import com.sun.source.util.TreePathScanner;
import com.sun.source.util.Trees;
import com.sun.tools.javac.code.Flags;
import com.sun.tools.javac.code.Symbol;
import com.sun.tools.javac.code.Symbol.MethodSymbol;
import com.sun.tools.javac.code.Type;
import com.sun.tools.javac.tree.JCTree;
import com.sun.tools.javac.tree.JCTree.JCClassDecl;
import com.sun.tools.javac.tree.JCTree.JCModifiers;
import com.sun.tools.javac.tree.TreeInfo;



/**
 * The JavaRecognizer does the work of converting Sun's abstract Java to abstract GOOL.
 * The documentation of abstract Java is at http://docs.oracle.com/javase/7/docs/api/javax/lang/model/package-summary.html
 * The class Context is necessary for that and is declared at the bottom of this file.
 */
public class JavaRecognizer extends TreePathScanner<Object, Context> {
	private static Logger logger = Logger.getLogger(JavaRecognizer.class);
	
	/**
	 * The Sun's abstract Java AST that we will now convert to abstract GOOL.
	 */
	private CompilationUnitTree ast;
	
	/**
	 * The type information that was obtained from Sun's java parser analysis of the AST.
	 */
	private Trees typetrees;
	
	/**
	 * The default platform used to specify the Target Language,
	 * which will be annotated in the newly created classes.
	 */
	private Platform defaultPlatform;
	
	/**
	 * The list of abstract GOOL classes and packages that will be generated.
	 */
	private Map<IType, ClassDef> goolClasses = new HashMap<IType, ClassDef>();
	private Map<String, Package> packagesCache = new HashMap<String, Package>();
	
	/**
	 * The list of keywords that may cause problems when generating target code
	 * from concrete or abstract GOOL.
	 */
	private static final Set<String> FORBIDDEN_KEYWORDS = new HashSet<String>();
	static {
		// C#
		FORBIDDEN_KEYWORDS.add("out");
		FORBIDDEN_KEYWORDS.add("params");
		FORBIDDEN_KEYWORDS.add("value");
		FORBIDDEN_KEYWORDS.add("out");
		FORBIDDEN_KEYWORDS.add("ref");
		FORBIDDEN_KEYWORDS.add("object");
		FORBIDDEN_KEYWORDS.add("string");
	}
	
	/**
	 * The map between Java operators and GOOL operators.
	 * Left are the Java abstract operators.
	 * Right are the GOOL abstract operators.
	 */
	static final private Map<Kind, Operator> operatorMap = new HashMap<Kind, Operator>();
	static {
		operatorMap.put(Kind.PLUS, Operator.PLUS);
		operatorMap.put(Kind.MINUS, Operator.MINUS);
		operatorMap.put(Kind.UNARY_MINUS, Operator.MINUS);
		operatorMap.put(Kind.MULTIPLY, Operator.MULT);
		operatorMap.put(Kind.DIVIDE, Operator.DIV);
		operatorMap.put(Kind.CONDITIONAL_AND, Operator.AND);
		operatorMap.put(Kind.CONDITIONAL_OR, Operator.OR);
		operatorMap.put(Kind.EQUAL_TO, Operator.EQUAL);
		operatorMap.put(Kind.NOT_EQUAL_TO, Operator.NOT_EQUAL);
		operatorMap.put(Kind.LESS_THAN, Operator.LT);
		operatorMap.put(Kind.LESS_THAN_EQUAL, Operator.LEQ);
		operatorMap.put(Kind.GREATER_THAN, Operator.GT);
		operatorMap.put(Kind.GREATER_THAN_EQUAL, Operator.GEQ);
		operatorMap.put(Kind.LOGICAL_COMPLEMENT, Operator.NOT);
		operatorMap.put(Kind.PREFIX_DECREMENT, Operator.PREFIX_DECREMENT);
		operatorMap.put(Kind.POSTFIX_DECREMENT, Operator.POSTFIX_DECREMENT);
		operatorMap.put(Kind.PREFIX_INCREMENT, Operator.PREFIX_INCREMENT);
		operatorMap.put(Kind.POSTFIX_INCREMENT, Operator.POSTFIX_INCREMENT);
	}

	/**
	 * Even though this is now our turn to take Sun's abstract Java and make it into abstract GOOL,
	 * It turns out that Sun's Java parser has already got a notion of TreePathScanner for traveling
	 * through its ASTs, which we here extend.
	 * Scan() is what launches the whole process.
	 */
	public void scan() {
		super.scan(ast,null);
	}
	
	/**
	 * Setters and getters
	 */
	public static void addForbiddenKeyword(String keyword) {
		FORBIDDEN_KEYWORDS.add(keyword);
	}

	public static void addForbiddenKeyword(File keywordsFile)
			throws IOException {
		BufferedReader reader = new BufferedReader(new FileReader(keywordsFile));

		String keyword;
		while ((keyword = reader.readLine()) != null) {
			addForbiddenKeyword(keyword);
		}
	}
	
	public final void setCurrentCompilationUnit(
			CompilationUnitTree currentCompilationUnit) {
		this.ast = currentCompilationUnit;
	}

	public final void setDefaultPlatform(Platform defaultPlatform) {
		this.defaultPlatform = defaultPlatform;
	}

	public final void setTrees(Trees typetrees) {
		this.typetrees = typetrees;
	}

	public final Collection<ClassDef> getGoolClasses() {
		return goolClasses.values();
	}
	
	private void addDependencyToContext(Context context, Dependency newDep) {
		if (newDep != null && context != null && context.getClassDef() != null) {
			context.getClassDef().addDependency(newDep);
		}
	}
	

	/**
	 * THIS PART IS ABOUT TYPE CONVERSION
	 */
	
	/**
	 * Converts Java abstract operator kinds to GOOL abstract operators.
	 */
	private Operator getOperator(Kind kind) {
		Operator result = operatorMap.get(kind);
		if (result == null) {
			result = Operator.UNKNOWN;
		}
		return result;
	}

	/**
	 * Get a Java type from a sub-branch of Java type tree.
	 */
	private TypeMirror getTypeMirror(Tree n) {
		TreePath path = TreePath.getPath(ast, n);
		TypeMirror typeMirror = typetrees.getTypeMirror(path);

		return typeMirror;
	}

	/**
	 * Get a GOOL Type from a sub-branch of Java type tree,
	 * and a context.
	 */
	private IType goolType(Tree n, Context context) {
		// A null abstract Java type usually means that we are dealing with a constructor.
		if (n == null) {
			return TypeNone.INSTANCE;
		}
		logger.debug("X");
		logger.debug(getTypeMirror(n));
		return goolType(getTypeMirror(n), context);
	}

	/**
	 * For primitive types.
	 * Converts Java type kinds to GOOL types.
	 */
	private IType goolType(TypeKind typeKind, String textualType) {
		switch (typeKind) {
		case BOOLEAN:
			return TypeBool.INSTANCE;
		case DOUBLE:
		case FLOAT:
			return TypeDecimal.INSTANCE;
		case SHORT:
		case INT:
		case LONG:
			return TypeInt.INSTANCE;
		case VOID:
			return TypeVoid.INSTANCE;
		case BYTE:
			return TypeByte.INSTANCE;
		case CHAR: 
			return TypeChar.INSTANCE;
		default:
			return new TypeUnknown(textualType);
		}
	}

	/**
	 * Get a GOOL Type from a Java type,
	 * and a context.
	 */
	private IType goolType(TypeMirror typeMirror, Context context) {
		
		if (typeMirror == null) {
			//A null abstract Java type usually means that we are dealing with a constructor.
			return TypeNone.INSTANCE;
		} 
		else if (typeMirror.getKind().isPrimitive()) {
			//Dealing with primitive types.
			//The overloaded goolType method will map Java abstract "kinds" to GOOL primitive types
			//The textualtype is for passing on unrecognized primitive types
			return goolType(typeMirror.getKind(), typeMirror.toString());
		}

		//Dealing with non-primitive types.
		//First, retrieve the full name of the Java type.
		Type type = (Type) typeMirror;
		Symbol classSymbol = (Symbol) type.asElement();
		logger.debug("XXX just before claiming a typeName from classsymbol XXX");
		logger.debug("XXX type, classSymbol, kind XXX");
		logger.debug(type);
		logger.debug(classSymbol);
		logger.debug(typeMirror.getKind());		
		logger.debug("XXX");
		String typeName;
		IType goolType;
		switch (typeMirror.getKind()) {
		case PACKAGE: // -- Dealing with Packages
			//Create a GOOL type of a type that matches the full name of the Java type.
			typeName = classSymbol.getSimpleName().toString();
			goolType = new TypePackage(typeName);
			//Whether in abstract Java of in GOOL, non-primitive types may have arguments. 
			//We convert them recursively, and add them up to the GOOL type.
			for (Type t : type.getTypeArguments()) {
				goolType.addArgument(goolType(t, context));
			}
			return goolType;
		case DECLARED: // -- Dealing with classes
			//Create a GOOL type of a type that matches the full name of the Java type.
			//Usually, this is a TypeClass, i.e. we assume that the type is some generic declared class.
			//However some classes receive a particular treatment like Lists, Maps etc.
			typeName = classSymbol.getSimpleName().toString();
			goolType = string2IType(typeName, context);
			
			//Whether in abstract Java or in GOOL, enums are codes as classes with some flag.
			//We deal with this case.
			boolean isEnum = ((classSymbol.flags() & Flags.ENUM) != 0);
			if (isEnum && goolType instanceof TypeClass) {
				((TypeClass) goolType).setIsEnum(isEnum);
			}

			//Whether in abstract Java of in GOOL, non-primitive types may have arguments. 
			//We convert them recursively, and add them up to the GOOL type.
			for (Type t : type.getTypeArguments()) {
				goolType.addArgument(goolType(t, context));
			}

			//TODO: sort out imports
			//Add the encountered type as a dependency of the current class, which is context.getClassDef().
			if (!type.toString().startsWith("java.lang")) {
				if (!goolType.toString().equalsIgnoreCase("gool")
						&& !context.getClassDef().getType().equals(goolType)) {
					context.getClassDef().addDependency(
							new TypeDependency(goolType));
				}
			}
			return goolType;
		case EXECUTABLE: // -- Dealing with methods
			//Create a GOOL type of a type that matches the Java type.
			typeName = "MethodType";
			goolType = new TypeMethod(typeName);
			//Whether in abstract Java of in GOOL, non-primitive types may have arguments. 
			//We convert them recursively, and add them up to the GOOL type.
			for (Type t : type.getTypeArguments()) {
				goolType.addArgument(goolType(t, context));
			}
			return goolType;
		case TYPEVAR: // -- Dealing type variables
			//Create a GOOL type of a type that matches the Java type.
			typeName = "TypeVarType";
			goolType = new TypeVar(typeName);
			//Whether in abstract Java of in GOOL, non-primitive types may have arguments. 
			//We convert them recursively, and add them up to the GOOL type.
			for (Type t : type.getTypeArguments()) {
				goolType.addArgument(goolType(t, context));
			}
			return goolType;
		case VOID:
			return TypeVoid.INSTANCE;
		case ARRAY:
			//Recognized a fixed length Array: int[ ] intarray = new int[6]. Not to be confused with java.util arrays.
			//Convert the type of the elements of the Array.
			//Then create a GOOL array type containing that elements of that converted type.
			//As for other kind of arrays like ArrayList etc., they fall under the DECLARED case. 
			ArrayType arrayType = (ArrayType) typeMirror;
			return new TypeArray(
					goolType(arrayType.getComponentType(), context));
		case NULL:
			return TypeNull.INSTANCE;
		default:
			//We met a type that we do not know how to handle.
			//Instead of throwing an error, we will just pass it on as such.
			return new TypeUnknown(typeMirror.toString());
		}
	}
	
	//These Otd are classes that return classes like TypeList, TypeMap,... 
	//why go through this intermediate step, and not replace the instantiations new Otd() by new TypeList(), new TypeMap... 
	//This is because these instances of Otd get placed in a map, 
	//which gets called with a string like List and replies with what should be, every time it gets called, a fresh instance of TypeList. 
	//Thus, returning and Otd wrapper and doing a getType() upon it does the job. It could have been handled through a case, though.
	private static abstract class Otd {
		abstract public IType getType();
	};

	private static final Map<String, Otd> string2otdMap = new HashMap<String, Otd>();
	static {
		
		Otd tmpOtd = new Otd() {
			public IType getType() {
				return TypeString.INSTANCE;
			}
		};
		string2otdMap.put("String", tmpOtd);
		string2otdMap.put("java.lang.String", tmpOtd);
		
		//We found a Java boxed Double.
		//As far as type goes, we unbox it and just say it is a GOOL Decimal.
		tmpOtd = new Otd() {
			public IType getType() {
				return TypeDecimal.INSTANCE;
			}
		};
		string2otdMap.put("java.lang.Double", tmpOtd);
		
		//We found a Java boxed Integer.
		//As far as type goes, we unbox it and just say it is a GOOL Int.
		tmpOtd = new Otd() {
			public IType getType() {
				return TypeInt.INSTANCE;
			}
		};
		string2otdMap.put("Integer", tmpOtd);
		string2otdMap.put("java.lang.Integer", tmpOtd);
		
		//NEXT We recognize that the abstact Java was using some well-known class
		//Which we want to treat in a particular manner
		//I.e. for which we have a specific representation in the abstract GOOL.
		
		tmpOtd = new Otd() {
			public IType getType() {
				return new TypeList();
			}
		};
				string2otdMap.put("List", tmpOtd);
		string2otdMap.put("ArrayList", tmpOtd);
		string2otdMap.put("java.util.ArrayList", tmpOtd);
		string2otdMap.put("gool.imports.java.util.ArrayList", tmpOtd);
		
		tmpOtd = new Otd() {
			public IType getType() {
				return new TypeMap();
			}
		};
		string2otdMap.put("Map", tmpOtd);
		string2otdMap.put("HashMap", tmpOtd);
		string2otdMap.put("java.util.HashMap", tmpOtd);
		string2otdMap.put("gool.imports.java.util.HashMap", tmpOtd);
		
		tmpOtd = new Otd() {
			public IType getType() {
				return new TypeEntry();
			}
		};
		string2otdMap.put("Entry", tmpOtd);
		string2otdMap.put("gool.imports.java.util.Map.Entry", tmpOtd);
		
		tmpOtd = new Otd() {
			public IType getType() {
				return new TypeFile();
			}
		};
		string2otdMap.put("File", tmpOtd);
		string2otdMap.put("java.io.File", tmpOtd);
		string2otdMap.put("gool.imports.java.io.File", tmpOtd);
		
		tmpOtd = new Otd() {
			public IType getType() {
				return new TypeFileReader();
			}
		};
		string2otdMap.put("FileReader", tmpOtd);
		string2otdMap.put("java.io.FileReader", tmpOtd);
		string2otdMap.put("gool.imports.java.io.FileReader", tmpOtd);
	
		tmpOtd = new Otd() {
			public IType getType() {
				return new TypeBufferedReader();
			}
		};
		string2otdMap.put("BufferedReader", tmpOtd);
		string2otdMap.put("java.io.BufferedReader", tmpOtd);
		string2otdMap.put("gool.imports.java.io.BufferedReader", tmpOtd);
		
		
		tmpOtd = new Otd() {
			public IType getType() {
				return new TypeFileWriter();
			}
		};
		string2otdMap.put("FileWriter", tmpOtd);
		string2otdMap.put("java.io.FileWriter", tmpOtd);
		string2otdMap.put("gool.imports.java.io.FileWriter", tmpOtd);
	
		tmpOtd = new Otd() {
			public IType getType() {
				return new TypeBufferedWriter();
			}
		};
		string2otdMap.put("BufferedWriter", tmpOtd);
		string2otdMap.put("java.io.BufferedWriter", tmpOtd);
		string2otdMap.put("gool.imports.java.io.BufferedWriter", tmpOtd);
		
		tmpOtd = new Otd() {
			public IType getType() {
				return new TypeException();
			}
		};
//		string2otdMap.put("Exception", tmpOtd);
		string2otdMap.put("java.lang.Exception", tmpOtd);
	}
	

	private IType string2IType(String typeName, Context context) {

		if (string2otdMap.containsKey(typeName)) {
			IType type = string2otdMap.get(typeName).getType();
			addDependencyToContext(context, new TypeDependency(type));
			return type;
		} else if (typeName.equalsIgnoreCase("Object")) {
			return TypeObject.INSTANCE;
		} else if (typeName.equalsIgnoreCase("Boolean")) {
			return TypeBool.INSTANCE;
		} else if (typeName.equalsIgnoreCase("Byte")) {
			return TypeByte.INSTANCE;
		} else {
			return new TypeClass(typeName);
		}
	}

	
	/**
	 * THIS PART IS ABOUT ANCILLARY METHODS THAT HELP VISITING
	 */
	
	/**
	 * When visiting a method or a constructor, one needs to go through the list of its arguments, 
	 * Visiting each of them recursively in turn, thereby generation an expression that gets added to the method or constructor.
	 * @param list
	 * @param expr
	 * @param context
	 */
	private void addParameters(List<? extends ExpressionTree> list,
			Parameterizable expr, Context context) {
		if (list != null) {
			for (ExpressionTree p : list) {
				Expression arg = (Expression) p.accept(this, context);
				if (arg != null) {
					expr.addParameter(arg);
				}
			}
		}
	}

	
	/**
	 * A subroutine to generate error messages, with the name of the file that caused the error.
	 * Notice that String.format(...) has the same sort of syntax to the old C printf.
	 * @param format: a string with holes
	 * @param message: data to fill in those holes
	 * @return a string: a filled in string, plus name of file concerned.
	 */
	private String error(String format, Object... message) {
		return String.format("%s [File %s]", String.format(format, message),
				ast.getSourceFile().getName());
	}

	
	/**
	 * Lets you check for a certain annotation; e.g.
	 * - "Override": used to set a inherited flag and that way be able to generate annotation.
	 * - "CustomCode": used to pass on code that should not be looked at by the GOOL system.
	 * @param list
	 * @param annotation
	 * @return
	 */
	public boolean findAnnotation(List<? extends AnnotationTree> list,
			String annotation) {
		for (AnnotationTree n : list) {
			if (n.getAnnotationType().toString().equals(annotation)) {
				return true;
			}
		}
		return false;
	}
	
	
	
	/**
	 * THIS PART IS ABOUT VISITING UNRECOGNIZED STUFF
	 *
	 * The following java abstract expressions are not recognized.
	 * This does not necessarily mean that they will not be handled correctly by the GOOL system.
	 * It means that there is no dedicated representation for them in abstract GOOL, other than ExpressionUnknown.
	 * Still, this ExpressionUnknown carries:
	 * - the type of the unrecognized expression;
	 * - the concrete Java string of characters that represents it.
	 */
	
	@Override
	public Object visitAssert(AssertTree n, Context context) {
		return new ExpressionUnknown(goolType(n,context),n.toString());
	}
	
	
	@Override
	public Object visitBreak(BreakTree n, Context context) {
		return new ExpressionUnknown(goolType(n,context),n.toString());
	}

	@Override
	public Object visitCase(CaseTree n, Context context) {
		return new ExpressionUnknown(goolType(n,context),n.toString());
	}

	@Override
	public Object visitCatch(CatchTree n, Context context) {
		Block block = new Block();
		
		for (StatementTree stmt : n.getBlock().getStatements()) {
			Statement statement = (Statement) stmt.accept(this, context);
			if (statement != null) {
				block.addStatement(statement);
			}
		}
		Catch returnCatch = new Catch(block);
		//Below adds the single parameter to the catch block
		VarDeclaration tempVarDeclaration = new VarDeclaration((Dec) n.getParameter().accept(this,
				context));
		returnCatch.setSingleParameter(tempVarDeclaration);
		return returnCatch;
	}
	
	@Override
	public Object visitCompoundAssignment(CompoundAssignmentTree n,
			Context context) {
		return new ExpressionUnknown(goolType(n,context),n.toString());
	}

	@Override
	public Object visitConditionalExpression(ConditionalExpressionTree n,
			Context context) {
		return new ExpressionUnknown(goolType(n,context),n.toString());
	}

	@Override
	public Object visitContinue(ContinueTree n, Context context) {
		return new ExpressionUnknown(goolType(n,context),n.toString());
	}

	@Override
	public Object visitDoWhileLoop(DoWhileLoopTree n, Context context) {
		return new ExpressionUnknown(goolType(n,context),n.toString());
	}

	@Override
	public Object visitEmptyStatement(EmptyStatementTree n, Context context) {
		return new ExpressionUnknown(goolType(n,context),n.toString());
	}
	
	@Override
	public Object visitInstanceOf(InstanceOfTree node, Context p) {
		return new ExpressionUnknown(goolType(node,p),node.toString());
	}

	@Override
	public Object visitLabeledStatement(LabeledStatementTree node, Context p) {
		return new ExpressionUnknown(goolType(node,p),node.toString());
	}

	@Override
	public Object visitOther(Tree node, Context p) {
		return new ExpressionUnknown(goolType(node,p),node.toString());

	}
	
	@Override
	public Object visitSwitch(SwitchTree node, Context p) {
		return new ExpressionUnknown(goolType(node,p),node.toString());
	}

	@Override
	public Object visitSynchronized(SynchronizedTree node, Context p) {
		return new ExpressionUnknown(goolType(node,p),node.toString());
	}

	@Override
	public Object visitThrow(ThrowTree node, Context p) {
		return new ExpressionUnknown(goolType(node,p),node.toString());
	}

	@Override
	public Object visitTry(TryTree node, Context p) {

		Block block = new Block();
		for (StatementTree stmt : node.getBlock().getStatements()) {
			Statement statement = (Statement) stmt.accept(this, p);
			if (statement != null) {
				block.addStatement(statement);
			}
		}
		
		List<Catch> catches = new ArrayList<Catch>();
		for(CatchTree catchTree:node.getCatches()) {
			catches.add((Catch) visitCatch(catchTree, p));
		}
		
		
		return new Try(block, catches);
	}

	@Override
	public Object visitTypeParameter(TypeParameterTree node, Context p) {
		return new ExpressionUnknown(goolType(node,p),node.toString());
	}
	
	@Override
	public Object visitWildcard(WildcardTree node, Context p) {
		return new ExpressionUnknown(goolType(node,p),node.toString());
	}
	
	
	/**
	 * THIS PART IS ABOUT VISITING RECOGNIZED STUFF : TYPES
	 * 
	 * Whenever we hit an abstract java type, we convert it to a goolType with goolType().
	 */
	@Override
	public Object visitArrayType(ArrayTypeTree n, Context context) {
		return goolType(n, context);
	}
	
	@Override
	public Object visitParameterizedType(ParameterizedTypeTree node,
			Context context) {
		return goolType(node, context);
	}

	@Override
	public Object visitPrimitiveType(PrimitiveTypeTree n, Context context) {
		return goolType(n.getPrimitiveTypeKind(), n.toString());
	}
	
	/**
	 * THIS PART IS ABOUT VISITING EASY RECURSIVE CASES
	 * 
	 * Whenever abstract java and abstract GOOL closely match, not much work is required: we just need to propagate the visit recursively,
	 * and make up the abstract GOOL from what is returned.
	 * 
	 * For example when visit some abstract java corresponding to a "t[i]" node, we visit t, visit i, and simply make up an
	 * ArrayAccess(visited t, visited i)
	 * abstract GOOL node.
	 * The following cases are akin.
	 */
	@Override
	public Object visitArrayAccess(ArrayAccessTree n, Context context) {
		return new ArrayAccess((Expression) n.getExpression().accept(this, context), (Expression) n.getIndex().accept(this, context));
	}
	
	@Override
	public Object visitAssignment(AssignmentTree n, Context context) {
		Node variable = (Node) n.getVariable().accept(this, context);
		Expression expression = (Expression) n.getExpression().accept(this,
				context);
		return new Assign(variable, expression);
	}

	@Override
	public Object visitBlock(BlockTree n, Context context) {
		Block block = new Block();
		for (StatementTree stmt : n.getStatements()) {
			Statement statement = (Statement) stmt.accept(this, context);
			if (statement != null) {
				block.addStatement(statement);
			}
		}
		return block;
	}

	@Override
	public Object visitWhileLoop(WhileLoopTree n, Context context) {
		return new While((Expression) n.getCondition().accept(this, context),
				(Statement) n.getStatement().accept(this, context));
	}
	
	@Override
	public Object visitForLoop(ForLoopTree node, Context p) {
		List<? extends StatementTree> initializers = node.getInitializer();
		if (initializers.size() > 1) {
			return new ExpressionUnknown(goolType(node,p),node.toString());
		}
		List<? extends StatementTree> updaters = node.getUpdate();
		if (updaters.size() > 1) {
			return new ExpressionUnknown(goolType(node,p),node.toString());
		}
		Statement initializer = (Statement) initializers.get(0).accept(this, p);
		Expression condition = (Expression) node.getCondition().accept(this, p);
		Statement updater = (Statement) updaters.get(0).accept(this, p);
		return new For(initializer, condition, updater, (Statement) node
				.getStatement().accept(this, p));
	}
	
	@Override
	public Object visitEnhancedForLoop(EnhancedForLoopTree n, Context context) {
		VarDeclaration varDec = (VarDeclaration) n.getVariable().accept(this,
				context);
		Expression expr = (Expression) n.getExpression().accept(this, context);

		Statement statements = (Statement) n.getStatement().accept(this,
				context);
		return new EnhancedForLoop(varDec, expr, statements);
	}

	@Override
	public Object visitIf(IfTree n, Context context) {
		Expression condition = (Expression) n.getCondition().accept(this,
				context);
		Statement thenStmt = (Statement) n.getThenStatement().accept(this,
				context);
		Statement elseStmt = null;
		if (n.getElseStatement() != null) {
			elseStmt = (Statement) n.getElseStatement().accept(this, context);
		}

		return new If(condition, thenStmt, elseStmt);
	}

	@Override
	public Object visitNewClass(NewClassTree n, Context context) {
		IType type = goolType(n.getIdentifier(), context);
		ClassNew c = new ClassNew(type);

		addParameters(n.getArguments(), c, context);

		return c;
	}
	
	@Override
	public Object visitParenthesized(ParenthesizedTree n, Context context) {
		return n.getExpression().accept(this, context);
	}

	@Override
	public Object visitReturn(ReturnTree node, Context p) {
		return new Return((Expression) node.getExpression().accept(this, p));
	}


	@Override
	public Object visitTypeCast(TypeCastTree node, Context context) {
		return new CastExpression(goolType(node.getType(), context),
				(Expression) node.getExpression().accept(this, context));
	}

	/**
	 * When visit some "op v" node, we visit v, translate op, work out the entire type...
	 * and make up a
	 * UnaryOperation(translated op, visited v, type, concrete java for op)
	 * abstract GOOL node.	
	 */
	@Override
	public Object visitUnary(UnaryTree n, Context context) {
		Expression expression = (Expression) n.getExpression().accept(this,
				context);
		Operator operator = getOperator(n.getKind());
		IType type=goolType(n,context);
		String textualoperator=  n.toString().replace(n.getExpression().toString(), "");
		return new UnaryOperation(operator, expression, type, textualoperator);
	}
	

	@Override
	public Object visitBinary(BinaryTree n, Context context) {
		
		Expression leftExp = (Expression) n.getLeftOperand().accept(this,
				context);
		Expression rightExp = (Expression) n.getRightOperand().accept(this,
				context);
		Operator operator = getOperator(n.getKind());
		IType type=goolType(n,context);
		String textualoperator= n.toString().replace(n.getLeftOperand().toString(), "").replace(n.getRightOperand().toString(), "");
		return new BinaryOperation(operator, leftExp, rightExp, type, textualoperator);
	}


	/**
	 * THIS PART IS ABOUT VISITING THE ODD CASES
	 */ 

	//This is when Sun's java parser failed.
	@Override
	public Object visitErroneous(ErroneousTree n, Context context) {
		throw new IllegalArgumentException(error(
				"The sun java parser failed at %s.", n.toString()));
	}

	//ExpressionStatements are just Expressions followed by semicolons.
	@Override
	public Object visitExpressionStatement(ExpressionStatementTree n,
			Context context) {
		return n.getExpression().accept(this, context);
	}

	/**
	 * THIS PART IS ABOUT VISITING THE DELICATE CASES
	 */ 
	
	/**
	 * Literals, Variables, Declarations
	 */
	
	/**
	 * Literals are simple values such as "3".
	 * Abstract GOOL represents them pretty much the same as abstract java.
	 */
	@Override
	public Object visitLiteral(LiteralTree n, Context context) {
		String value = n.getValue() != null ? n.getValue().toString() : "null";
		return new Constant(goolType(n, context), value);
	}

	/**
	 * Deals with variable declarations.
	 */
	@Override
	public Object visitVariable(VariableTree n, Context context) {
		if (FORBIDDEN_KEYWORDS.contains(n.getName().toString())) {
			throw new IllegalArgumentException(error(
					"The variable named '%s' uses reserved keyword.", n
							.getName()));
		}
		//work out the GOOL type of the variable
		IType type = goolType(n.getType(), context);
		//work out the name, and make an abstract GOOL variable declaration
		VarDeclaration variable = new VarDeclaration(type, n.getName()
				.toString());
		//find whether there is an initializing expression and if so, visit it, and add the result to the GOOL variable declaration
		if (n.getInitializer() != null) {
			Expression initializer = (Expression) n.getInitializer().accept(
					this, context);
			variable.setInitialValue(initializer);
		}
		
		//a variable declaration may be an attribute declaration (a field), in which case it carries modifiers 
		//and gets represented differently in GOOL, i.e. wrapped up with a Field().
		// TODO: actually, any variable declaration could have modifiers.
		Collection<Modifier> modifiers = (Collection<Modifier>) n
				.getModifiers().accept(this, context);
		if (n.getType() instanceof MemberSelectTree || !modifiers.isEmpty()) {
			return new Field(modifiers, variable);
		}
		
		return variable;
	}

	@Override
	public Object visitIdentifier(IdentifierTree n, Context context) {
		if (FORBIDDEN_KEYWORDS.contains(n.getName().toString())) {
			throw new IllegalArgumentException(error(
					"The variable named '%s' uses reserved keyword.", n
							.getName()));
		}

		IType type = goolType(n, context);


		// TODO identifiers. Create a specific node to access to class literal (i.e. when calling static members).
		if (type.getName().equals(n.getName().toString())) {
			return new Constant(type, n.getName().toString());
		}
		
		//This method returns a VarAccess, accessing a previously declared variable, i.e. a VarDeclaration.
		//TODO: The link to the suitable VarDeclaration should be done by name analysis.
		//For not we just create a dummy VarDeclaration for that purpose.
		VarDeclaration varDec = new VarDeclaration(goolType(n, context), n
				.getName().toString());
		return new VarAccess(varDec);
	}
	

	
	/**
	 * Lists, maps
	 */


	/**
	 * List declarations are not passed on, but represented as such in abstract GOOL.
	 * We need to work out the type, the dimensions, and the initialization of the list before in order to build up the 
	 * ArrayNew(type, dimensions,initialization)
	 * abstract GOOL node that represents it.
	 */
	@Override
	public Object visitNewArray(NewArrayTree node, Context p) {
		List<Expression> initialiList = new ArrayList<Expression>();
		if (node.getInitializers() != null) {
			for (ExpressionTree expression : node.getInitializers()) {
				initialiList.add((Expression) expression.accept(this, p));
			}
		}
		List<Expression> dimesExpressions = new ArrayList<Expression>();
		if (node.getDimensions() != null) {

			for (ExpressionTree expression : node.getDimensions()) {
				dimesExpressions.add((Expression) expression.accept(this, p));
			}
		}
		return new ArrayNew(goolType(node.getType(), p), dimesExpressions,
				initialiList);
	}
	
	/**
	 * Deals with expressions like "target.identifier()".
	 * It gets called by visitMethodInvokation().
	 */
	@Override
	public Object visitMemberSelect(MemberSelectTree n, Context context) {
		Expression target = (Expression) n.getExpression()
				.accept(this, context);
		String identifier = n.getIdentifier().toString();
		logger.debug("XX Entering MemberSelect with target-identifier XX");
		logger.debug(target);
		logger.debug(identifier);
		logger.debug("XX");
		/*
		 * TODO Currently we are assuming that the following methods are always the same as the methods
		 * "toString" and "equals" belonging to the Object class.
		 */
		if (identifier.equalsIgnoreCase("equals")) {
			return new EqualsCall(target);
		}
		if (identifier.equals("toString")) {
			return new ToStringCall(target);
		}

		IType type = target.getType();
		logger.debug("X Target type X");
		logger.debug(type);
		logger.debug("X");

		if (type != null) {

			if (type instanceof TypeList) {
				if (identifier.equals("add")) {
					return new ListAddCall(target);
				}
				if (identifier.equals("remove")) {
					return new ListRemoveCall(target);
				}
				if (identifier.equals("removeAt")) {
					return new ListRemoveAtCall(target);
				}
				if (identifier.equals("get")) {
					return new ListGetCall(target);
				}
				if (identifier.equals("size")) {
					return new ListSizeCall(target);
				}
				if (identifier.equals("isEmpty")) {
					return new ListIsEmptyCall(target);
				}
				if (identifier.equals("getIterator")) {
					return new ListGetIteratorCall(target);
				}
				if (identifier.equals("contains")) {
					return new ListContainsCall(target);
				}
			}
			if (type instanceof TypeMap) {
				if (identifier.equals("put")) {
					return new MapPutCall(target);
				}
				if (identifier.equals("remove")) {
					return new MapRemoveCall(target);
				}
				if (identifier.equals("get")) {
					return new MapGetCall(target);
				}
				if (identifier.equals("size")) {
					return new MapSizeCall(target);
				}
				if (identifier.equals("isEmpty")) {
					return new MapIsEmptyCall(target);
				}
				if (identifier.equals("getIterator")) {
					return new MapGetIteratorCall(target);
				}
				if (identifier.equals("containsKey")) {
					return new MapContainsKeyCall(target);
				}
				if (identifier.equals("entrySet")) {
					return target;
				}
			}
			if (type instanceof TypeEntry) {
				if (identifier.equals("getKey")) {
					return new MapEntryGetKeyCall(target);
				}
				if (identifier.equals("getValue")) {
					return new MapEntryGetValueCall(target);
				}
			}
			if (type instanceof TypeBufferedReader) {
				if (identifier.equals("readLine")) {
					return new BufferedReaderReadLineCall(target);
				}
				if (identifier.equals("read")) {
					return new BufferedReaderReadCall(target);
				}
				if (identifier.equals("close")) {
					return new BufferedReaderCloseCall(target);
				}
			}
			if (type instanceof TypeException) {
				if (identifier.equals("printStackTrace")) {
					return new ExceptionPrintStackTraceCall(target);
				}
			}
			if (type instanceof TypeBufferedWriter) {
				if (identifier.equals("write")) {
					return new BufferedWriterWriteCall(target);
				}
				if (identifier.equals("close")) {
					return new BufferedWriterCloseCall(target);
				}
				if (identifier.equals("flush")) {
					return new BufferedWriterFlushCall(target);
				}
				if (identifier.equals("newLine")) {
					return new BufferedWriterNewLineCall(target);
				}
			}
			if (type instanceof TypeFile) {
				if (identifier.equals("isFile")) {
					return new FileIsFileCall(target);
				}
				if (identifier.equals("isDirectory")) {
					return new FileIsDirectoryCall(target);
				}
				if (identifier.equals("delete")) {
					return new FileDeleteCall(target);
				}
				if (identifier.equals("exists")) {
					return new FileExistsCall(target);
				}
			}
		}
		//the type of the target
		//or the identifier
		//were not recognized
		//i.e. it is not a library that requires a particular treatment
		//it gets the standard treatment.
		logger.debug("X Standard method call for X");
		logger.debug(n);
		IType goolType = goolType(n, context);
		logger.debug("X");
		MemberSelect f = new MemberSelect(goolType, target, n.getIdentifier()
				.toString());
		return f;
	}

	/**
	 * Classes, packages, imports...
	 */
	
	@Override
	public Object visitClass(ClassTree n, Context context) {
		
		//Get the name of the class
		JCClassDecl c = (JCClassDecl) n;
		ClassDef classDef = new ClassDef(n.getSimpleName().toString());
		System.out.println(String.format("Parsing class %s", n.getSimpleName()));
		
		//The new class will provide the context for the things parsed inside of it.
		Context newContext = new Context(classDef, null);
		
		//Enums are just classes with a particular flag, which we set up if necessary
		//We said that before, with DECLARED types
		//Here this is for the class itself
		classDef.setIsEnum((c.mods.flags & Flags.ENUM) != 0);


		Collection<Modifier> modifiers = (Collection<Modifier>) n
				.getModifiers().accept(this, newContext);
		/*
		 * For now do not allow 'static' modifier for classes, as it means very different things
		 * in the target languages.
		 * TODO: static class support.
		 */
		modifiers.remove(Modifier.STATIC);

		/*
		 * For now classes must be 'public' in order to solve accessibility in the
		 * target languages.
		 * TODO: more visibility support.
		 */
		modifiers.add(Modifier.PUBLIC);

		//The forceplatform annotation is unused for now
		//The idea is to be able to specify the target platform
		//As an annotation of the concrete input language
		for (AnnotationTree annotationTree : n.getModifiers().getAnnotations()) {
			if (annotationTree.getAnnotationType().toString().equals(
					"ForcePlatform")) {
				if (annotationTree.getArguments().size() > 0) {
					Node an = (Node) annotationTree.getArguments().get(0)
							.accept(this, newContext);

					if (an instanceof Assign) {
						Platform platform = Platform
								.valueOf(((Constant) ((Assign) an).getValue())
										.getValue().toString());
						if (platform != null) {
							classDef.setPlatform(platform);
						}
						break;
					}
				}
				throw new IllegalStateException(
						error("The ForcePlatform annotation should have a platform as its parameter. For example @ForcePlatform(platform=\"JAVA\")"));
			}
		}

		//Let us deal with modifiers
		classDef.setModifiers(modifiers);

		JCModifiers mtree = (JCModifiers) n.getModifiers();
		classDef.setIsInterface((mtree.flags & Flags.INTERFACE) != 0);

		// Make sure some Target language is specified for this class.
		if (classDef.getPlatform() == null) {
			classDef.setPlatform(defaultPlatform);
		}

		// Register the class as one of the outputs
		goolClasses.put(classDef.getType(), classDef);

		/*
		 * If the class has the CustomCode annotation, we enerate a class 
		 * without processing the code inside
		 * but just commenting it 
		 * Indeed, notice that
		 * createMethod(MethodTree n, Context context, boolean createOnlySignature, boolean commentOriginalCode)
		 */
		boolean customCode = findAnnotation(n.getModifiers().getAnnotations(),
				"CustomCode");
		if (customCode) {
			for (Tree tree : n.getMembers()) {
				if (tree instanceof MethodTree) {
					MethodTree method = (MethodTree) tree;
					classDef.addMethod(createMethod(method, newContext, true,
							false));
				}
			}
			return classDef;
		}

		//Setup Inheritance information
		if (n.getExtendsClause() != null) {
			IType parentType = goolType(n.getExtendsClause(), newContext);
			classDef.setParentClass(parentType);
		}
		for (Tree iface : n.getImplementsClause()) {
			classDef.addInterface(goolType(iface, newContext));
		}

		//Recursively go through each member and add it to the abstract GOOL class
		for (Tree tree : n.getMembers()) {
			Node member = (Node) tree.accept(this, newContext);
			if (member instanceof Meth) {
				classDef.addMethod((Meth) member);
			} else if (member instanceof Field) {
				classDef.addField((Field) member);
			} else if (member instanceof VarDeclaration) {
				classDef.addField(new Field(Arrays.asList(Modifier.PRIVATE),
						(VarDeclaration) member));
			} else if (member != null) {
				System.out.println(String.format(
						"Unrecognized member for class %s: %s ", classDef
								.getName(), member));
			}
		}

		return classDef;
	}

	/**
	 * This is the beginning of the visit. 
	 * But it gets called several times, once per compilation unit.
	 * A CompilationUnit is a Java file
	 * But a java file can have various classes inside.
	 */
	@Override
	public Object visitCompilationUnit(CompilationUnitTree n, Context context) {
		//The destination package is either null or that specified by the visited package
		String ppackage = null;
		if (n.getPackageName() != null) {
			ppackage = n.getPackageName().accept(this, context).toString();
		}
		//Dealing with the imports
		//Each class that is imported is registered as a dependency
		//TODO: We don't automatically go and compile dependencies.
		List<Dependency> dependencies = new ArrayList<Dependency>();
		for (ImportTree imp : n.getImports()) {
			String dependencyString = imp.getQualifiedIdentifier().toString();
			if (!dependencyString.contains("gool.imports.java")
					&& !dependencyString
							.contains("gool.imports.java.annotations")) {
				dependencies.add(new CustomDependency(dependencyString));
			}
		}
		//Visit each member class in turn
		//And add it to the Dependencies too
		//Each class may have a package.
		//In order not to create two different GOOL packages
		//when the JAVA packages names were in fact the same
		//we remember the package name in the packagesCache.
		for (Tree unit : n.getTypeDecls()) {
			ClassDef classDef = (ClassDef) unit.accept(this, context);
			if (ppackage != null) {
				Package p = packagesCache.get(ppackage);
				if (p == null) {
					p = new Package(ppackage);
					packagesCache.put(ppackage, p);
				}
				p.addClass(classDef);
				classDef.setPpackage(p);
			}
			classDef.addDependencies(dependencies);
		}
		return null;
	}

	//This was handled already with the getImports of visitCompilationUnit
	@Override
	public Object visitImport(ImportTree n, Context context) {
		throw new IllegalStateException(
				"return TypeDependency(TypeClass(n.getQualifiedIdentifier().accept(this, context).toString()))");
	}

	/**
	 * Methods
	 */
	
	@Override
	public Object visitMethod(MethodTree n, Context context) {
		boolean customCode = findAnnotation(n.getModifiers().getAnnotations(),
				"CustomCode");
		boolean isInherited = findAnnotation(n.getModifiers().getAnnotations(),
				"Override");

		Meth method = createMethod(n, context, customCode, true);
		method.setInherited(isInherited);

		return method;
	}

	private Meth createMethod(MethodTree n, Context context,
			boolean createOnlySignature, boolean commentOriginalCode) {
		Meth method;

		//recover modifiers
		Collection<Modifier> modifiers = (Collection<Modifier>) n
				.getModifiers().accept(this, context);

		//deal with the case of constructors....
		//XXXXXXXXXXXXXXXX why is there no argument to the contructor???
		if (n.getReturnType() == null) {
			method = new Constructor();
		} else {
			IType type = goolType(n.getReturnType(), context);
			/*
			 * The hard way to determine if the current method is the entry
			 * point.
			 * It may be better if we implement this as an annotation.
			 * XXXXXXXXXXXXX All this to see if it is a Main?
			 * XXXXXXXXXXXXX what is the logic of it?
			 * XXXXXXXXXXXXX Why not see if it is called main?
			 */
			boolean isMainMethod = type.equals(TypeVoid.INSTANCE)
					&& modifiers.contains(Modifier.PUBLIC)
					&& modifiers.contains(Modifier.STATIC);

			if (n.getParameters() != null && n.getParameters().size() == 1) {
				IType t = goolType(n.getParameters().get(0).getType(), context);

				if (t instanceof TypeArray) {
					isMainMethod &= ((TypeArray) t).getElementType().equals(
							TypeString.INSTANCE);
				} else {
					isMainMethod = false;
				}
			} else {
				isMainMethod = false;
			}

			if (isMainMethod) {
				method = new MainMeth();
			} else {
				method = new Meth(type, n.getName().toString());
			}
		}

		//go through each parameter and add it.
		if (n.getParameters() != null) {
			for (VariableTree p : n.getParameters()) {
				method.addParameter(new VarDeclaration((Dec) p.accept(this,
						context)));
			}
		}

		//Can we safely move it to L1298?
		method.setModifiers(modifiers);

		//XXXXXXXXXXXXXX What is this entire if for?
		if (n.getBody() != null) {
			if (createOnlySignature) {
				if (commentOriginalCode) {
					method.addStatement(new Comment(n.getBody().toString()));
				}

				if (!TypeVoid.INSTANCE.equals(method.getType())
						&& !method.isConstructor()) {
					String returnValue = "null";
					IType returnType;
					if (method.getType() instanceof TypeInt) {
						returnValue = "-1";
						returnType = TypeInt.INSTANCE;
					} else if (method.getType() instanceof TypeBool) {
						returnValue = "false";
						returnType = TypeBool.INSTANCE;
					} else if (method.getType() instanceof TypeByte) {
						returnValue = "0";
						returnType = TypeByte.INSTANCE;
					} else {
						returnType = TypeNull.INSTANCE;
					}
					method.addStatement(new Return(new Constant(returnType,
							returnValue)));
				}

			} else {
				for (StatementTree stmt : n.getBody().getStatements()) {
					Statement statement = (Statement) stmt
							.accept(this, context);
					if (statement instanceof InitCall
							&& method instanceof Constructor) {
						((Constructor) method)
								.addInitCall((InitCall) statement);
					} else if (statement != null) {
						method.addStatement(statement);
					}
				}
			}
		}
		return method;
	}

	/**
	 * XXXXXXXXXXXXX Could you explain what the main steps are?
	 * This is the time to deal with recognition of certain library calls such as System.out.println
	 * Indeed, System.out.println is imbricated:
	 * MethodInvocation(<Target:MemberSelect<Target:MemberSelect<Target:"System", Identifier:"out">,<Identifier:"println">>>)
	 * So it is easier to identify at this stage
	 */
	@Override
	public Object visitMethodInvocation(MethodInvocationTree n, Context context) {
		Symbol method = (Symbol) TreeInfo.symbol((JCTree) n.getMethodSelect());	
		Expression target;
		if (n.getMethodSelect().toString().equals("System.out.println")) {
			context.getClassDef().addDependency(new SystemOutDependency());
			target = new SystemOutPrintCall();
		}
		else if (n.getMethodSelect().toString().equals("super")) {
				target = new ParentCall(goolType(((MethodSymbol) method)
						.getReturnType(), context));
		}
		else if (n.getMethodSelect().toString().equals("this")) {
				target = new ThisCall(goolType(((MethodSymbol) method)
						.getReturnType(), context));
		} 
		else {
				logger.debug("YYYY from method to member select YYYY");
				logger.debug(n.getMethodSelect().toString());
				//System.out.println("YYYYYYYYYYYY");
			// The target is the xxxx part of some method invocation xxxx().
			// Here is when we possibly visitMemberSelect().
			target = (Expression) n.getMethodSelect().accept(this,
					context);
		}
	
		if (!(target instanceof Parameterizable)) {
				target = new MethCall(goolType(((MethodSymbol) method)
						.getReturnType(), context), target);
		}
		
		addParameters(n.getArguments(), (Parameterizable) target, context);
		return target;
	}

	/**
	 * Translates abstract Java modifiers into abstract GOOL modifiers
	 */
	@Override
	public Object visitModifiers(ModifiersTree n, Context context) {
		Collection<Modifier> result = new HashSet<Modifier>();

		Set<javax.lang.model.element.Modifier> flags = n.getFlags();

		for (javax.lang.model.element.Modifier modifier : flags) {
			switch (modifier) {
			case PRIVATE:
				result.add(Modifier.PRIVATE);
				break;
			case PUBLIC:
				result.add(Modifier.PUBLIC);
				break;
			case PROTECTED:
				result.add(Modifier.PROTECTED);
				break;
			case STATIC:
				result.add(Modifier.STATIC);
				break;
			case ABSTRACT:
				result.add(Modifier.ABSTRACT);
				break;
			case FINAL:
				result.add(Modifier.FINAL);
				break;
			case VOLATILE:
				result.add(Modifier.VOLATILE);
				break;
			case TRANSIENT:
				result.add(Modifier.TRANSIENT);
				break;
			case NATIVE:
				result.add(Modifier.NATIVE);
				break;
			case STRICTFP:
				result.add(Modifier.STRICTFP);
				break;
			case SYNCHRONIZED:
				result.add(Modifier.SYNCHRONIZED);
				break;
		}}

		return result;
	}

}

class Context {
	/**
	 * When we hit an "import MyCustomClass" in Java, we make an "import MyCustomClass" in GOOL: it must be passed on. 
	 * Later as we visit the Java tree downwards (from root to leafs), we propagate this context information.
	 * This is because if something has been redefined in such a MyCustomClass.java, it must be treated differently 
	 * from something of the same name without this context. 
	 * For instance mycustom.List will be passed on, whereas List might have been translated.
	 */
	private ClassDef classDef;

	public Context(ClassDef currentClass, Block currentBlock) {
		this.classDef = currentClass;
	}

	public ClassDef getClassDef() {
		return classDef;
	}

}

